/*
  Copyright (c) 2020 Augusto Goulart

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
*/
#include "wrappem.h"

Export::Export(const DWORD ordinal, const DWORD hint, const DWORD rva, const char* name, const DWORD index)
{
  hint_ = hint;
  ordinal_ = ordinal;
  rva_ = rva;

  only_ordinal_ = FALSE;
  if (nullptr != strstr(name, "[NONAME]")) {
    only_ordinal_ = TRUE;
    name_ = new string("___XXX___");
    *name_ += to_string(index);
  } else {
    name_ = new string(name);
  }

  index_ = index;
}

Export::~Export()
{
  delete name_;
}

inline string CstrToUpper(const string str)
{
  string buff = "";
  for (auto rit = str.cbegin(); rit != str.cend(); ++rit)
    buff += ('a' <= *rit && *rit <= 'z') ? (*rit)^0x20 : *rit;
  return buff;
}

inline DWORD GetDword(WORD high, WORD low)
{
  DWORD r = (high << 16) | low;
  return r;
}

inline void Mkdir(char* path)
{
  string workdir = "";
  char* context = nullptr;
  char* folder = strtok_s(path, "/\\", &context);
  while (nullptr != folder) {
    workdir += folder;
    _mkdir(workdir.data());
    folder = strtok_s(nullptr, "/\\", &context);
  }
}

inline string RemoveFileExt(char* filename)
{
  string noext = string(filename);
  for (auto rit = noext.crbegin(); rit != noext.crend(); ++rit) {
    if (*rit == '.') {
      noext.pop_back();
      break;
    }
    noext.pop_back();
  }
  return noext;
}

int main(int argc, char* argv[])
{
  try {
    bool x86arch = true;

    cout << "\n\t\t" << _C(36, PROJECT_NAME) << ' ' << _C(36, PROJECT_VERSION) << '\n'
         << "\tCopyright (C) 2020 Augusto Goulart\n\n"
         << "\tWrappEm: Verifying arguments...\n\n";

    if (argc >= 2) {
      if (!strcmp(argv[1], "--help")) {
        cout << "Usage: wrappem [--help] " _C(95, "<dll> <exports> <original> <out>") << " [/nocpp]\n\n"
             << "\t--help\t\t\tshow this help message\n"
             << '\t' << _C(95, "dll") << "\t\tis the name of your proxy DLL (i.e. version.dll)\n"
             << '\t' << _C(95, "exports") << "\t\tis a text file containing the exports from the original DLL\n"
             << '\t' << _C(95, "original") << "\tis the DLL name that your proxy DLL will try to load\n"
             << '\t' << _C(95, "out") << "\t\toutput directory\n"
             << "\t/64\t\t\tgenerate files for 64-bits (default is 32-bits)\n";
        exit(EXIT_SUCCESS);
      } else if (argc < 4) {
        throw invalid_argument("Not enough arguments");
      }
    } else {
      throw invalid_argument("Zero arguments provided");
    }

    if (argc > 5)
      x86arch = (strcmp(argv[5], "/64") != 0);

    unique_ptr<vector<Export*>> exports(new vector<Export*>);
    ifstream ifile;

    cout << "\tWrappEm: Starting tasks...\n"
         << "\t\t" << _C(44, " TASK ") << "\tParsing exports from " << argv[2] << "...\n";
    ifile.open(argv[2]);

    const streamsize size = 1000;
    unique_ptr<char[]> line(new char[size]);
    unique_ptr<char[]> name(new char[size]);
    DWORD ordinal, hint, rva;

    ifile.getline(line.get(), size);
    if (nullptr == strstr(line.get(), "Microsoft (R) COFF/PE Dumper"))
      throw runtime_error("Exports file must have been generated by dumpbin.exe");

    DWORD index = 0;
    bool found = false;
    while (ifile.getline(line.get(), size)) {
      if (!found) {
        if (nullptr != strstr(line.get(), "ordinal hint RVA      name")) {
          found = true;
          while (isspace(ifile.peek()))
            ifile.get();
        }
      } else if (4 == sscanf_s(line.get(), "%d %x %x %s", &ordinal, &hint, &rva, name.get(), static_cast<unsigned int>(size))) {
        exports->push_back(new Export(ordinal, hint, rva, name.get(), index));
        ++index;
      } else if (3 == sscanf_s(line.get(), "%d %x %s", &ordinal, &hint, name.get(), static_cast<unsigned int>(size))) {
        exports->push_back(new Export(ordinal, hint, 0, name.get(), index));
        ++index;
      }
      name.get()[0] = '\0';
    }
    if (!found)
      throw runtime_error("Exports file is not correctly formatted");

    ifile.close();
    cout << "\t\t" << _C(42, " SUCCESS ") << "\tParsed " << exports->size() << " exported functions\n";

    ofstream ofile;
    Mkdir(argv[4]);

    cout << "\t\t" << _C(44, " TASK ") << "\tGenerating Assembly file dllmain.asm...\n";
    ofile.open(string(argv[4]).append("/dllmain.asm"));

    ofile << (x86arch) ? "extern _address\n\n" : "extern address\n\n";
    ofile << "section .text\n";

    for (size_t i = 0; i < exports->size(); ++i)
      ofile << "\tglobal " << *(*exports)[i]->name_ << "_\n";
    for (size_t i = 0; i < exports->size(); ++i) {
      ofile << '\n' << *(*exports)[i]->name_ << "_:\n";
      if (x86arch)
        ofile << "\tjmp [_address + " << (*exports)[i]->index_ * sizeof(FARPROC) << "]\n";
      else
        ofile << "\tmov rax, address\n" << "\tjmp [rax + " << (*exports)[i]->index_ * sizeof(FARPROC) << "]\n";
    }

    ofile.close();
    cout << "\t\t" << _C(42, " SUCCESS ") << "\tWritten " << exports->size() << " proxy functions to Assembly file\n";

    cout << "\t\t" << _C(44, " TASK ") << "\tGenerating DEF file...\n";
    ofile.open(string(argv[4]).append("/dllmain.def"));

    ofile << "LIBRARY " << CstrToUpper(RemoveFileExt(argv[1])) << '\n'
          << "EXPORTS\n";
    for (size_t i = 0; i < exports->size(); ++i)
      ofile << '\t' << *(*exports)[i]->name_ << '=' << *(*exports)[i]->name_ << "_ @" << (*exports)[i]->ordinal_ << '\n';

    ofile.close();
    cout << "\t\t" << _C(42, " SUCCESS ") << "\tWritten " << exports->size() << " proxy functions to DEF file\n";

    cout << "\t\t" << _C(44, " TASK ") << "\tGenerating C++ file dllmain.cpp...\n";
    ofile.open(string(argv[4]).append("/dllmain.cpp"));

    ofile << "#include <Windows.h>\n"
          << "#pragma pack(1)\n\n"
          << "HINSTANCE hInst = 0;\n"
          << "HINSTANCE hL = 0;\n\n"
          << "extern \"C\" FARPROC address[" << exports->size() << "] = {0};\n\n";

    ofile << "BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)\n"
          << "{\n"
          << "\tswitch (fdwReason)\n"
          << "\t{\n"
          << "\tcase DLL_PROCESS_ATTACH:\n"
          << "\t\thInst = hinstDLL;\n"
          << "\t\thL = LoadLibrary(TEXT(\".\\\\" << argv[3] << "\"));\n"
          << "\t\tif (!hL) return FALSE;\n\n";

    for (size_t i = 0; i < exports->size(); ++i) {
      if ((*exports)[i]->only_ordinal_ == TRUE)
        ofile << "\t\taddress[" << i << "] = GetProcAddress(hL, " << GetDword(0, (*exports)[i]->ordinal_) << ");\n";
      else
        ofile << "\t\taddress[" << i << "] = GetProcAddress(hL, \"" << *(*exports)[i]->name_ << "\");\n";
    }

    ofile << "\t\tbreak;\n\n"
          << "\tcase DLL_PROCESS_DETACH:\n"
          << "\t\tFreeLibrary(hL);\n"
          << "\t\tbreak;\n\n"
          << "\tdefault:\n"
          << "\t\treturn FALSE;\n"
          << "\t}\n"
          << "\treturn TRUE;\n"
          << "}\n";

    ofile.close();
    cout << "\t\t" << _C(42, " SUCCESS ") << "\tWritten " << exports->size() << " proxy functions to C++ file\n";
  } catch (const exception& e) {
    cerr << "\t\t" << _C(41, " FAIL ") << '\t' << e.what() << "\n\n";
    exit(EXIT_FAILURE);
  }
  exit(EXIT_SUCCESS);
}
